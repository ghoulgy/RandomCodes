try:
    from cStringIO import StringIO as BytesIO
except ImportError:
    from io import BytesIO

import pycdlib, os, sys
import argparse
from pycdlib import utils
import collections
from pycdlib import dr
from pycdlib import eltorito
from pycdlib import facade
from pycdlib import headervd
from pycdlib import inode
from pycdlib import isohybrid
from pycdlib import path_table_record
from pycdlib import pycdlibexception
from pycdlib import pycdlibio
from pycdlib import udf as udfmod
import bisect
import collections
import inspect
import io
import logging
import os
import struct
import sys

NAME = 0
have_py_3 = True

# Monkey Patch
def walk2(self, **kwargs):
      # type: (str) -> Generator
      """
      Walk the entries on the ISO, starting at the given path.  One, and only
      one, of iso_path, rr_path, joliet_path, and udf_path is allowed.
      Similar to os.walk(), yield a 3-tuple of (path-to-here, dirlist, filelist)
      for each directory level.

      Parameters:
       iso_path - The absolute ISO path to the starting entry on the ISO.
       rr_path - The absolute Rock Ridge path to the starting entry on the ISO.
       joliet_path - The absolute Joliet path to the starting entry on the ISO.
       udf_path - The absolute UDF path to the starting entry on the ISO.
      Yields:
       3-tuples of (path-to-here, dirlist, filelist)
      Returns:
       Nothing.
      """
      if not self._initialized:
          raise pycdlibexception.PyCdlibInvalidInput('This object is not initialized; call either open() or new() to create an ISO')

      num_paths = 0
      for key, value in kwargs.items():
          if key in ('joliet_path', 'rr_path', 'iso_path', 'udf_path'):
              if value is not None:
                  num_paths += 1
          else:
              raise pycdlibexception.PyCdlibInvalidInput("Invalid keyword, must be one of 'iso_path', 'rr_path', 'joliet_path', or 'udf_path'")

      if num_paths != 1:
          raise pycdlibexception.PyCdlibInvalidInput("Must specify one, and only one of 'iso_path', 'rr_path', 'joliet_path', or 'udf_path'")

      rec = None  # type: Optional[Union[dr.DirectoryRecord, udfmod.UDFFileEntry]]
      if 'joliet_path' in kwargs:
          joliet_path = self._normalize_joliet_path(kwargs['joliet_path'])
          rec = self._find_joliet_record(joliet_path)
          path_type = 'joliet_path'
          encoding = 'utf-16_be'
      elif 'udf_path' in kwargs:
          if self.udf_root is None:
              raise pycdlibexception.PyCdlibInvalidInput('Can only specify a UDF path for a UDF ISO')
          (ident_unused, rec) = self._find_udf_record(utils.normpath(kwargs['udf_path']))
          if rec is None:
              raise pycdlibexception.PyCdlibInvalidInput('Cannot get entry for empty UDF File Entry')
          path_type = 'udf_path'
          encoding = ''
      elif 'rr_path' in kwargs:
          if not self.rock_ridge:
              raise pycdlibexception.PyCdlibInvalidInput('Cannot fetch a rr_path from a non-Rock Ridge ISO')
          rec = self._find_rr_record(utils.normpath(kwargs['rr_path']))
          path_type = 'rr_path'
          encoding = 'utf-8'
      else:
          rec = self._find_iso_record(utils.normpath(kwargs['iso_path']))
          path_type = 'iso_path'
          encoding = 'latin-1'

      dirs = collections.deque([rec])
      while dirs:
          dir_record = dirs.popleft()

          relpath = self.full_path_from_dirrecord(dir_record,
                                                  rockridge=path_type == 'rr_path')
          dirlist = []
          filelist = []
          dirdict = {}

          for child in reversed(list(self.list_children(**{path_type: relpath}))):
              if child is None or child.is_dot() or child.is_dotdot():
                  continue

              if isinstance(child, udfmod.UDFFileEntry) and child.file_ident is not None:
                  encoding = child.file_ident.encoding

              if path_type == 'rr_path':
                  name = child.rock_ridge.name()
              else:
                  name = child.file_identifier()

              if have_py_3:
                  # Python 3, just return the encoded version.
                  encoded = name.decode(encoding)
              else:
                  # Python 2.
                  encoded = name.decode(encoding).encode('utf-8')

              if child.is_dir():
                  dirlist.append(encoded)
                  dirdict[encoded] = child
              else:
                  filelist.append(encoded)

          yield relpath, dirlist, filelist

          # We allow the user to modify dirlist along the way, so we
          # add the children to dirs *after* yield returns.
          for name in dirlist:
              dirs.appendleft(dirdict[name])


pycdlib.PyCdlib.walk = walk2

# Main code
def print_iso_output(file, print_format, iso_filelist):
  if print_format == NAME: 
    print(f"{file}")

  else:
    print(f"\n{file}")

    for idx, iso_file in enumerate(iso_filelist): 
      print(idx+1, iso_file)


def get_iso_file_list(path, mode=None, size=None, print_format=None):
  for dirname, _, filelist in os.walk(path):
    for file in filelist:      
      try:
        iso = pycdlib.PyCdlib()

        iso.open(os.path.join(path, file)) 
        for _, _, iso_filelist in iso.walk(iso_path='/'):
          if not mode and not size:
            print_iso_output(file, print_format, iso_filelist)

          elif mode == "eq" and len(iso_filelist) == size:
            print_iso_output(file, print_format, iso_filelist)

          elif mode == "gt" and len(iso_filelist) > size:
            print_iso_output(file, print_format, iso_filelist)

          elif mode == "lt" and len(iso_filelist) < size:
            print_iso_output(file, print_format, iso_filelist)

        iso.close()

      except Exception as ex:
        print(f"\n{file} {ex} ")


usage = 'usage: prog [path] -m <mode> -s <size>'
parser = argparse.ArgumentParser(
  usage=usage,
  description='Just normal ISO parser based on pycdlib')

parser.add_argument(
  'path', type=str,
  help='Full path to iso file')

parser.add_argument(
  '-m', '--mode', type=str, required=False,
  help='Equal(eq), Greater than(gt) or Lesser than(lt)')

parser.add_argument(
  '-s', '--size', type=int, required=False,
  help='ISO child size')

parser.add_argument(
  '-pf', '--print_format', type=int, required=False,
  help='Print format')

args = parser.parse_args()

path = args.path
mode = args.mode
size = args.size
print_format = args.print_format

# /home/ubuntu/Downloads/iso/intelligencefiles/20220630T173628

get_iso_file_list(path, mode, size, print_format)