# f5915d3efdd31d03fdcd84c9ea109232417c4861996a3e6eda16c7156fb59042
import base64
import string
from arc4 import ARC4

dec_routine = 0x403893
xrefs = CodeRefsTo(dec_routine, 0)
key = b"1670491607004543356898504"

def b64_rc4_crypt(enc_str):
    #print(enc_str)
    b64_dec_str = base64.b64decode(enc_str)
    cipher = ARC4(key)
    final_dec_str = cipher.decrypt(b64_dec_str)
    
    print(final_dec_str)
    return final_dec_str


def ida_rename_dword(forward_addr, dec_str):
    dword_addr = get_operand_value(forward_addr, 0)
    print(hex(dword_addr))
    punc_list = string.punctuation
    dec_str = dec_str.replace(" ", "_SPACE_").replace("\t", "_TAB_")

    for punc in punc_list:
        if punc == "_":
            continue
        if punc in dec_str:
            dec_str = dec_str.replace(punc, "_BC_")
    
    dec_str = "mal_" + dec_str        
    idc.set_name(dword_addr, dec_str)


for xref in xrefs:
    backward_addr = prev_head(xref)

    if idc.print_insn_mnem(backward_addr) == "mov":
        offset_addr = get_operand_value(backward_addr, 1)
    elif idc.print_insn_mnem(backward_addr) == "push":
        offset_addr = get_operand_value(backward_addr, 0)
    else:
        print(f"Failed: {hex(backward_addr)}")
    
    offset_val = idc.get_bytes(offset_addr, 0x100)
    print(hex(backward_addr))
    
    if offset_val[:offset_val.find(b"\x00")] == b"1670491607004543356898504":
        print("skip")
        continue
    
    dec_str = b64_rc4_crypt(offset_val[:offset_val.find(b"\x00")])
    dec_str = dec_str.decode()
    
    # Comment the decrypted string on the disassembly view
    idc.set_cmt(xref, dec_str, 0)
    
    # Rename the dword constant in disassembly view
    forward_addr = next_head(xref)
    if idc.print_insn_mnem(forward_addr) == "mov":
        ida_rename_dword(forward_addr, dec_str)
    else:
        print(f"Skip renamed dword at addr {forward_addr}")
