# Copy those library and its base address from "Symbols" section in xdbg64
# It will copy those library from windows system path (bit is depands on the version of python used) into the working directory
# This is for 32 bit DLL

import os
import struct
import shutil

dll_loaded_addr_dict = {
    "logoncli.dll": "6CA20000",     
    "netapi32.dll": "6CA60000",     
    "userenv.dll": "6DED0000",      
    "samcli.dll": "6E2A0000",       
    "wkscli.dll": "6E970000",       
    "windowscodecs.dll": "70B30000",
    "netutils.dll": "71950000",     
    "srvcli.dll": "71970000",       
    "uxtheme.dll": "72D90000",      
    "ole32.dll": "75B50000",        
    "combase.dll": "75C40000",      
    "gdi32.dll": "75F50000",        
    "rpcrt4.dll": "75F80000",       
    "bcrypt.dll": "76040000",       
    "user32.dll": "76230000",       
    "win32u.dll": "763D0000",       
    "kernel32.dll": "76400000",     
    "shlwapi.dll": "76540000",      
    "kernelbase.dll": "76640000",   
    "gdi32full.dll": "76860000",    
    "sechost.dll": "76960000",      
    "ws2_32.dll": "76B50000",       
    "oleaut32.dll": "76BC0000",     
    "msvcrt.dll": "76D20000",       
    "ucrtbase.dll": "76DF0000",     
    "shell32.dll": "76F10000",      
    "imm32.dll": "77680000",        
    "msvcp_win.dll": "776B0000",    
    "advapi32.dll": "77730000",     
    "ntdll.dll": "77C90000"
}   


def mod_pe_imagebase_addr(file, new_imagebase_addr):
    new_imagebase_addr = bytearray.fromhex(new_imagebase_addr)

    pe_binary_mod = open("modded_" + file, "wb")

    pe_binary = open(file ,"rb")
    pe_content = pe_binary.read()
    pe_byte_array = bytearray(pe_content)
    ptr_elfanew = pe_byte_array[0x3c:0x40]
    elfanew_val = struct.unpack("<I", ptr_elfanew)[0]
    print(f"[+] elfanew value: {hex(elfanew_val)}")
    ptr_imagebase = elfanew_val + 0x34
    print(hex(ptr_imagebase))
    print(f"[+] Imagebase value: {pe_byte_array[ptr_imagebase:ptr_imagebase + 0x4]}")
    print(f'[+] Before: {hex(struct.unpack("<I", pe_byte_array[ptr_imagebase:ptr_imagebase + 0x4])[0])}')
    new_imagebase_addr.reverse()
    pe_byte_array[ptr_imagebase:ptr_imagebase + 0x4] = new_imagebase_addr
    print(f'[+] After: {hex(struct.unpack("<I", pe_byte_array[ptr_imagebase:ptr_imagebase + 0x4])[0])}')

    pe_binary_mod.write(pe_byte_array)
    pe_binary_mod.close()
    pe_binary.close()

    return True


sys32_dll_list = dll_loaded_addr_dict.keys()
executor_file_path = os.path.dirname(os.path.realpath(__file__))

for dll_name, dll_loaded_addr in dll_loaded_addr_dict.items():  
    file_path = os.path.join("C:\\Windows\\SysWOW64", dll_name)

    if os.path.isfile(file_path):
        destination_file_path = os.path.join(executor_file_path, dll_name)
        if not os.path.isfile(destination_file_path):
            try:
                shutil.copyfile(file_path, destination_file_path)
            except PermissionError:
                print(f"{file_path} permission error!")
                continue
            except:
                print(f"{file_path} other error!")
                continue

        else:
            print(f"{destination_file_path} already exist!")

        if mod_pe_imagebase_addr(dll_name, dll_loaded_addr):
            print(f"[+] {destination_file_path} mod success")

        else:
            print(f"[+] {destination_file_path} mod error")

    else:
        print(f"{file_path} not found!")
